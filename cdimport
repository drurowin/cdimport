#!/usr/bin/env zsh

# cdimport - semi-automatic CD import script

# Copyright (C) 2013 Lucien Pullen <drurowin@gmail.com>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

[[ -z $CDIMPORT_DEST ]] && CDIMPORT_DEST=$HOME/Music/cdimport

VERSION='1.2'

[[ $# -eq 0 ]] && {
    echo "Usage: cdimport [-nT] [-d input] [-e extension] [-F ffmpeg] [-f metapath]"
    echo "                [-o outpath] [@meta-name value]..."
    echo "       cdimport --help"
    echo "       cdimport --version"
    exit
}

function print_help() {
    groff -m man -T "$1" <<GROFFER | less
.TH cdimport 1 "2013-03"
.SH NAME
cdimport \- semi-automatic CD import script

.SH SYNOPSIS

\fBcdimport [-nT] [-d \fIinput\fB] [-e \fIextension\fB] [-F
\fIffmpeg\fB] [-f \fImetapath\fB] [-o \fIoutpath\fB] [@\fImeta-name
value\fB]... [@\fImeta-name\fP=\fIvalue\fB]...\fP

\fBcdimport --help\fP

\fBcdimport --version\fP

.SH DESCRIPTION

\fBcdimport\fP imports a CD or other collected music data into a
central location. Additionally, \fBcdimport\fP sets relevant
metadata. The track title and track number (if present) are set
automatically from the file name (but see the \fB@\fP option for an
exception).

This utility relies on \fBffmpeg\fP(1) to do the conversion. As such,
it must be installed to do anything useful. Coincidentally, this also
means that the wide variety of input formats that ffmpeg understands
are understood by this program.

Summary information is printed to STDERR, and is used as an aid in
double-checking metadata and save location before running. Since some
CDs can take a long time to process, this is a good time to find
mistakes. This summary may be safely discarded.

This script has been written with the opinion that a computer should
store lossless copies of CD audio. Popular disk drives are large and
cheap enough to support this ideal. As such, support for "lossy"
formats like MPEG audio and Vorbis will never be officially
included. If such a need arises, use your favorite conversion utility
to do the translation, or modify the script yourself.

.SS OUTPUT FORMAT

Files are saved using the FLAC format. The naming scheme is as
follows:

.in +2
\fIdisc#\fP.\fItrack#\fP -- \fItitle\fP.flac
.in -2

When there is no disc number, the naming scheme is:

.in +2
\fItrack#\fP -- \fItitle\fP.flac
.in -2

When there is no track number, the naming scheme is:

.in +2
\fItitle\fP.flac
.in -2

.SH OPTIONS

.IP "-d, --dir \fIinput-path\fP"

Use \fIinput-path\fP as the read directory. The default value is
\$PWD.

.IP "-e, --ext \fIextension\fP"

Only read in files with the extension \fIextension\fP. This is useful
when the directory also contains album art.

.IP "-F \fIffmpeg\fP"

Use the given path \fIffmpeg\fP as the location of the ffmpeg
binary. The default value is the lead of \$PATH. If no binary can be
found, or one is found but is invalid, the program will not continue.

.IP "-f \fImeta-path\fP"

Search path for ffmetadata files. Default is to use the input
directory.

See the section FFMETADATA for a quick summary of the basics of this
file.

.IP "-h, --help"

Display this help.

.IP "-n, --dry-run"

Display the ffmpeg commands that the utility would use, but do not
execute them. The commands are printed to STDOUT.

.IP "-o, --outdir \fIoutput-path\fP"

By default, files are saved in "\fIartist\fP/\fIalbum\fP" in the
prefix \$CDIMPORT_DEST. This option overrides that entire path, for
when such behavior is unwanted.

.IP "-T"

By default, \fBcdimport\fP uses the first word of the file name as the
track number. When this behavior is not wanted, \fB\-T\fP turns this
off.

.IP "-v, --version"

Display the program name and version, then exit.

.IP "@\fImeta-name\fP \fIvalue\fP OR @\fImeta-name\fP=\fIvalue\fP"

Option for passing track metadata to ffmpeg. Specify this option as
many times as there is metadata to pass. The second form allows sane
shell expansion.

To pass track-specific metadata, use the form
"\fItrack\fP:\fImeta-name\fP". When 'title' is specified this way (and
\fBONLY\fP this way!), it will override track title from file name
calculation. This form is only meaningful when not using -T.

Declared metadata, embedded metadata, and ffmetadata file metadata
follow the following rules:

.in +2

\fB1.\fP ffmetadata file metadata overrides embedded metadata.

\fB2.\fP Declared metadata overrides ffmetadata file metadata.

\fB3.\fP Declared metadata is unique. Redeclaring metadata clobbers
the previous definition.

\fB4.\fP Track-specific declared metadata overrides non-track-specific
metadata.

\fB5.\fP All metadata keys cannot have an equal sign ("=") in
them. This is a limitation imposed by ffmpeg. Values may have equal
signs.

.in -2

.SH FFMETADATA

There is a supported ffmpeg input format called "ffmetadata" that
stores track metadata similar to an INI file. This file must start
with the line ";FFMETADATA1". Following are lines
"\fIkey\fP=\fIvalue\fP".

.SH ENVIRONMENT

.IP CDIMPORT_DEST

If set and not empty, this is the target prefix of converted
files. The default value is "\$HOME/Music/cdimport".

.SH BUGS

None that I'm aware of!

.SH AUTHOR

Lucien Pullen <drurowin@gmail.com>

.SH "SEE ALSO"

.BR ffmpeg (1)

GROFFER
}

ERR=0

DIR=$(pwd)
METAPATH=
EXT=
FFMPEG=
OUTPATH=

typeset -A metadata
typeset -A track_metadata
NUMBER=t

NOEXEC=

while test ! -z "$1"; do
    [[ $(echo "$1" | cut -c 1) == "@" ]] && {
        meta=${1[2,-1]}
        track=$(print -- $meta | awk 'BEGIN {FS=":"} /:/ {print $1}')
        name=$(print -- $meta | awk 'BEGIN {FS=":"} /:/ {print $2}')
        [[ -z $track ]] && name=$meta
        [[ ! -z $(print -- $name | awk '/=/ {print "="}') ]] && {
            name=$(print -- $name | awk 'BEGIN {FS="="} {print $1}')
            value=$(print -- $meta | awk 'BEGIN {FS="="} {res=$2; for(i = 3; i <= NF; i++) { res = res "=" $i; } print res; }')
            shift
        } || {
            value=$2
            shift 2
        }
        name=$(print -- $name | gawk '{print tolower($0)}')
        [[ -z $track ]] && {
            metadata[$name]=$value
        } || {
            track_metadata[$(printf "%i:%s" "$track" "$name")]=$value
            [[ -z $metadata[$name] ]] && metadata[$name]=""
        }
        continue
    }
    [[ $(echo -- "$1" | cut -c 1) != "-" ]] && {
        shift
        continue
    }
    case "$1" in
        -d|--dir)
            DIR=$2
            shift 2
            ;;
        -e|--ext)
            EXT=$2
            shift 2
            ;;
        -F|--ffmpeg)
            FFMPEG=$2
            shift 2
            ;;
        -f)
            METAPATH=$2
            shift 2
            ;;
        -h|--help)
            [[ $(print -- $2 | cut -c 1) == "T" ]] && {
                fmt=${2[2,-1]}
            } || {
                fmt=ascii
            }
            print_help "${fmt}"
            exit
            ;;
        -n|--dry-run)
            NOEXEC=noexec
            shift
            ;;
        -o|--outdir)
            OUTPATH=$2
            shift 2
            ;;
        -T)
            NUMBER=
            shift
            ;;
        -v|--version)
            echo "cdimport v$VERSION"
            exit
            ;;
        *)
            echo "Unexpected Argument '$1'" >&2
            shift
            ;;
    esac
done

[[ ! -d $DIR ]] && {
    DIR="[31m$DIR[0m"
    ERR+=1
}

[[ -z $METAPATH ]] && METAPATH=$DIR

[[ -z $FFMPEG ]] && {
    ffmpeg >/dev/null 2>/dev/null
    case $? in
        126)
            FFMPEG="[31mno exec[0m"
            ERR+=1
            ;;
        127)
            FFMPEG="[31mno[0m"
            ERR+=1
            ;;
        *)
            FFMPEG=$(which ffmpeg)
            ;;
    esac
}

function check() {
    [[ ! -z $2 ]] && {
        printf "%-28s%s\n" "$1" "$2"
    } || {
        printf "%-28s%s\n" "$1" "$3"
    }
}

function escape() {
    echo \'$(echo $1 | sed "s/'/'\\\''/g")\'
}

function sanitize() {
    echo $(echo $1 | sed 's/\[//g;s/\]//g;s/['\''"(){}:]//g;s/[ ]\{2,\}/ /g;s/\///g')
}

check "Testing for FFmpeg..." "$FFMPEG" >&2
check "Input path" "$DIR" >&2
check "FFmetadata path" "$METAPATH" >&2
check "Output path" "$OUTPATH" "$CDIMPORT_DEST" >&2
check "Embedded track number" "$NUMBER" >&2
check "File extension" "$EXT" "*" >&2
echo "Declared metadata" >&2
for k in ${(k)metadata}; do
    [[ ! -z $metadata[$k] ]] && echo "\t$k: ${metadata[$k]}" >&2
done
for k in ${(k)track_metadata}; do
    echo "\t$k: $track_metadata[$k]" >&2
done

((ERR > 0)) && exit 1

FILES=("${(@f)$(ls -1 "$DIR")}")

for f in $FILES; do
    [[ ! -z $EXT && ${f##*.} != $EXT ]] && continue;
    [[ ${f##*.} == "ffmetadata" ]] && continue;

    FILE=$(echo -n $f | awk 'BEGIN {FS="/"} {print $NF}')
    TITLE=$FILE
    DISC=
    [[ $NUMBER == "t" ]] && {
        TRK=$(echo $FILE | awk '{print $1}')

        TITLE=$(echo $FILE | awk '{$1=""; print}')

        FFMETAFILE=$METAPATH/$TRK.ffmetadata
    }
    TITLE=$(echo ${TITLE%.*} | sed $'s/^[ \t]*//;s/[ \t]*$//')

    CMD="$FFMPEG -i $(escape "$DIR/$FILE")"
    [[ -r $FFMETAFILE && -f $FFMETAFILE ]] && {
        CMD+=" -i $(escape "$FFMETAFILE") -map_metadata 0:1"
        FFTITLE=$(gawk 'BEGIN {FS="="} /^title=/ {print $NF}' $FFMETAFILE)
        ALBUM=$(gawk 'BEGIN {FS="="} /^album=/ {print $NF}' $FFMETAFILE)
        ARTIST=$(gawk 'BEGIN {FS="="} /^artist=/ {print $NF}' $FFMETAFILE)
        track=$(gawk 'BEGIN {FS="="} /^track=/ {print $NF}' $FFMETAFILE)
        DISC=$(gawk 'BEGIN {FS="="} /^disc(number)?=/ {print $NF}' $FFMETAFILE)
        [[ ! -z $track ]] && TRK=$track
    }

    for meta in ${(k)metadata}; do
        value=$track_metadata[$(printf "%i:%s" "$TRK" "$meta")]
        [[ -z $value ]] && [[ -z $metadata[$meta] ]] && continue
        [[ -z $value ]] && value=$metadata[$meta]
        case "$meta" in
            title)
                unset FFTITLE
                TITLE=$value
                ;;
            disc|discnumber)
                DISC=$value
                CMD+=" -metadata $meta=$(escape "$value")"
                ;;
            *)
                CMD+=" -metadata $meta=$(escape "$value")"
                ;;
        esac
    done

    [[ $NUMBER == "t" ]] && CMD+=" -metadata track=$(printf "%i" "$TRK")"

    [[ ! -z $OUTPATH ]] && {
        TARGET=$OUTPATH
    } || {
        [[ -z $ALBUM ]] && ALBUM=$metadata[album]
        [[ -z $ARTIST ]] && ARTIST=$metadata[artist]
        TARGET=$CDIMPORT_DEST/$(sanitize "$ARTIST")/$(sanitize "$ALBUM")
    }

    [[ ! -z $FFTITLE ]] && {
        TITLE=$FFTITLE
    } || {
        CMD+=" -metadata title=$(escape "$TITLE")"
    }
    DISC=$(echo $DISC | gawk 'BEGIN {FS="/"} {print $1}')
    [[ ! -z $DISC && ! -z $TRK ]] && {
        DISC=$(printf "%02i." $DISC)
    } || {
        DISC=
    }
    [[ ! -z $TRK ]] && TRK=$(printf "%02i -- " $TRK)
    CMD+=" -y '$TARGET/$DISC$TRK$(sanitize "$TITLE").flac'"

    [[ ! -z $NOEXEC ]] && {
        echo $CMD
    } || {
        mkdir -p "$TARGET"
        eval $CMD
    }
done
