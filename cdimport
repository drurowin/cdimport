#!/usr/bin/env zsh

# cdimport - semi-automatic CD import script

# Copyright (C) 2013 Lucien Pullen <drurowin@gmail.com>
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

[[ -z $CDIMPORT_DEST ]] && CDIMPORT_DEST=$HOME/Music/cdimport

VERSION='1.1'

[[ $# -eq 0 ]] && {
    echo "Usage: cdimport [-nT] [-d input] [-e extension] [-F ffmpeg] [-f metapath]"
    echo "                [-o outpath] [@meta-name value]*"
    echo "       cdimport --help"
    echo "       cdimport --version"
    exit
}

function print_help() {
    groff -m man -T "$1" <<GROFFER | less
.TH cdimport 1 "2013-03"
.SH NAME
cdimport \- semi-automatic CD import script

.SH SYNOPSIS

\fBcdimport [-nT] [-d \fIinput\fB] [-e \fIextension\fB] [-F
\fIffmpeg\fB] [-f \fImetapath\fB] [-o \fIoutpath\fB] [@\fImeta-name
value\fB]*\fP

\fBcdimport --help\fP

\fBcdimport --version\fP

.SH DESCRIPTION

\fBcdimport\fP imports a CD or other collected music data into a
central location. Additionally, \fBcdimport\fP sets relevant
metadata. The track title and track number (if present) are set
automatically from the file name (but see the \fB@\fP option for an
exception). Options are processed in the order specified. Later
override earlier ones.

This utility relies on \fBffmpeg\fP(1) to do the conversion. As such,
it must be installed to do anything useful. Coincidentally, this also
means that the wide variety of input formats that ffmpeg understands
are understood by this program.

Summary information is printed to STDERR, and is used as an aid in
double-checking metadata and save location before running. Since some
CDs can take a long time to process, this is a good time to find
mistakes. This summary may be safely discarded.

This script has been written with the opinion that a computer should
store lossless copies of CD audio. Popular disk drives are large and
cheap enough to support this ideal. As such, support for "lossy"
formats like MPEG audio and Vorbis will never be officially
included. If such a need arises, use your favorite conversion utility
to do the translation, or modify the script yourself.

.SS OUTPUT FORMAT

Files are saved using the FLAC format. The naming scheme is as
follows:

.in +2
\fIdisc#\fP.\fItrack#\fP \-\- \fItitle\fP.flac
.in -2

When there is no track number (-T was specified and there was no
"track" field in the ffmetadata file), the fields "disc#" and
"track#", and the leading dot, will be absent.

When there is no disc number (not declared or in ffmetadata file), the
field "disc#" and the proceeding dot will be absent.

When neither the track number nor disc number are specified, the file
name will be as such:

.in +2
\fItitle\fP.flac
.in -2

.SH OPTIONS

.IP "-d, --dir \fIinput-path\fP"

Use \fIinput-path\fP as the read directory. The default value is
\$PWD.

.IP "-e, --ext \fIextension\fP"

Only read in files with the extension \fIextension\fP. This is useful
when the directory also contains album art.

.IP "-F \fIffmpeg\fP"

Use the given path \fIffmpeg\fP as the location of the ffmpeg
binary. The default value is the lead of \$PATH. If no binary can be
found, or one is found but is invalid, the program will not continue.

.IP "-f \fImeta-path\fP"

Search path for ffmetadata files. Default is to use the input
directory.

See the section FFMETADATA for a quick summary of the basics of this
file.

.IP "-h, --help"

Display this help.

.IP "-n, --dry-run"

Display the ffmpeg commands that the utility would use, but do not
execute them. The commands are printed to STDOUT.

.IP "-o, --outdir \fIoutput-path\fP"

By default, files are saved in "\fIartist\fP/\fIalbum\fP" in the
prefix \$CDIMPORT_DEST. This option overrides that entire path, for
when such behavior is unwanted.

.IP "-T"

By default, \fBcdimport\fP uses the first word of the file name as the
track number. When this behavior is not wanted, \fB\-T\fP turns this
off.

.IP "-v, --version"

Display the program name and version, then exit.

.IP "@\fImeta-name\fP \fIvalue\fP"

Option for passing track metadata to ffmpeg. Specify this option as
many times as there is metadata to pass.

To pass track-specific metadata, use the form
"\fItrack\fP:\fImeta-name\fP". When 'title' is specified this way (and
\fBONLY\fP this way!), it will override track title from file name
calculation. This form is only meaningful when not using -T.

.SH FFMETADATA

There is a supported ffmpeg input format called "ffmetadata" that
stores track metadata similar to an INI file. This file must start
with the line ";FFMETADATA1". Following are lines
"\fIkey\fP=\fIvalue\fP".

.SH ENVIRONMENT

.IP CDIMPORT_DEST

If set and not empty, this is the target prefix of converted
files. The default value is "\$HOME/Music/cdimport".

.SH BUGS

None that I'm aware of!

.SH AUTHOR

Lucien Pullen <drurowin@gmail.com>

.SH "SEE ALSO"

.BR ffmpeg (1)

GROFFER
}

ERR=0

DIR=$(pwd)
METAPATH=
EXT=
FFMPEG=
OUTPATH=

typeset -A metadata
NUMBER=t

NOEXEC=

while test ! -z "$1"; do
    [[ $(echo "$1" | cut -c 1) == "@" ]] && {
        metadata[${1[2,-1]}]=$2
        shift 2
        continue
    }
    [[ $(echo -- "$1" | cut -c 1) != "-" ]] && {
        shift
        continue
    }
    case "$1" in
        -d|--dir)
            DIR=$2
            shift 2
            ;;
        -e|--ext)
            EXT=$2
            shift 2
            ;;
        -F|--ffmpeg)
            FFMPEG=$2
            shift 2
            ;;
        -f)
            METAPATH=$2
            shift 2
            ;;
        -h|--help)
            [[ $(print -- $2 | cut -c 1) == "T" ]] && {
                fmt=${2[2,-1]}
            } || {
                fmt=ascii
            }
            print_help "${fmt}"
            exit
            ;;
        -n|--dry-run)
            NOEXEC=noexec
            shift
            ;;
        -o|--outdir)
            OUTPATH=$2
            shift 2
            ;;
        -T)
            NUMBER=
            shift
            ;;
        -v|--version)
            echo "cdimport v$VERSION"
            exit
            ;;
        *)
            echo "Unexpected Argument '$1'" >&2
            shift
            ;;
    esac
done

[[ ! -d $DIR ]] && {
    DIR="[31m$DIR[0m"
    ERR+=1
}

[[ -z $METAPATH ]] && METAPATH=$DIR

[[ -z $FFMPEG ]] && {
    ffmpeg >/dev/null 2>/dev/null
    case $? in
        126)
            FFMPEG="[31mno exec[0m"
            ERR+=1
            ;;
        127)
            FFMPEG="[31mno[0m"
            ERR+=1
            ;;
        *)
            FFMPEG=$(which ffmpeg)
            ;;
    esac
}

function check() {
    [[ ! -z $2 ]] && {
        printf "%-28s%s\n" "$1" "$2"
    } || {
        printf "%-28s%s\n" "$1" "$3"
    }
}

function escape() {
    echo \'$(echo $1 | sed "s/'/'\\\''/g")\'
}

function sanitize() {
    echo $(echo $1 | sed 's/\[//g;s/\]//g;s/['\''"(){}:]//g;s/[ ]\{2,\}/ /g;s/\///g')
}

check "Testing for FFmpeg..." "$FFMPEG" >&2
check "Input path" "$DIR" >&2
check "FFmetadata path" "$METAPATH" >&2
check "Output path" "$OUTPATH" "$CDIMPORT_DEST" >&2
check "Embedded track number" "$NUMBER" >&2
check "File extension" "$EXT" "*" >&2
echo "Declared metadata" >&2
for k in ${(k)metadata}; do
    echo "\t$k: ${metadata[$k]}" >&2
done
[[ ! -z $NOEXEC ]] && echo "[33mDry running.[0m" >&2

((ERR > 0)) && exit 1

FILES=("${(@f)$(ls -1 "$DIR")}")

for f in $FILES; do
    [[ ! -z $EXT && ${f##*.} != $EXT ]] && continue;
    [[ ${f##*.} == "ffmetadata" ]] && continue;

    FILE=$(echo -n $f | awk 'BEGIN {FS="/"} {print $NF}')
    TITLE=$FILE
    DISC=
    [[ $NUMBER == "t" ]] && {
        TRK=$(echo $FILE | awk '{print $1}')

        TITLE=$(echo $FILE | awk '{$1=""; print}')

        FFMETAFILE=$METAPATH/$TRK.ffmetadata
    }
    TITLE=$(echo ${TITLE%.*} | sed $'s/^[ \t]*//;s/[ \t]*$//')

    CMD="$FFMPEG -i $(escape "$DIR/$FILE")"
    [[ -r $FFMETAFILE && -f $FFMETAFILE ]] && {
        CMD+=" -i $(escape "$FFMETAFILE") -map_metadata 0:1"
        FFTITLE=$(gawk 'BEGIN {FS="="} /^title=/ {print $NF}' $FFMETAFILE)
        ALBUM=$(gawk 'BEGIN {FS="="} /^album=/ {print $NF}' $FFMETAFILE)
        ARTIST=$(gawk 'BEGIN {FS="="} /^artist=/ {print $NF}' $FFMETAFILE)
        track=$(gawk 'BEGIN {FS="="} /^track=/ {print $NF}' $FFMETAFILE)
        DISC=$(gawk 'BEGIN {FS="="} /^disc(number)?=/ {print $NF}' $FFMETAFILE)
        [[ ! -z $track ]] && TRK=$track
    }

    for meta in ${(k)metadata}; do
        track=$(echo $meta | awk 'BEGIN {FS=":"} /:/ {print $1}')
        name=$(echo $meta | awk 'BEGIN {FS=":"} /:/ {print $2}')
        value=${metadata[$meta]}
        [[ -z $track ]] && name=$meta
        name=$(print -- $name | gawk '{print tolower($0)}')
        [[ -z $track ]] && {
            case "$name" in
                disc|discnumber)
                    DISC=$value
                    CMD+=" -metadata $name=$(escape "$value")"
                    ;;
                *)
                    CMD+=" -metadata $name=$(escape "$value")"
                    ;;
            esac
        } || {
            ((track == TRK)) && {
                case "$name" in
                    title)
                        unset FFTITLE
                        TITLE=$value
                        ;;
                    disc|discnumber)
                        DISC=$value
                        CMD+=" -metadata $name=$(escape "$value")"
                        ;;
                    *)
                        CMD+=" -metadata $name=$(escape "$value")"
                        ;;
                esac
            }
        }
    done

    [[ $NUMBER == "t" ]] && CMD+=" -metadata track=$TRK"

    [[ ! -z $OUTPATH ]] && {
        TARGET=$OUTPATH
    } || {
        [[ -z $ALBUM ]] && ALBUM=$metadata[album]
        [[ -z $ARTIST ]] && ARTIST=$metadata[artist]
        TARGET=$CDIMPORT_DEST/$(sanitize "$ARTIST")/$(sanitize "$ALBUM")
    }

    [[ ! -z $FFTITLE ]] && {
        TITLE=$FFTITLE
    } || {
        CMD+=" -metadata title=$(escape "$TITLE")"
    }
    DISC=$(echo $DISC | gawk 'BEGIN {FS="/"} {print $1}')
    [[ ! -z $DISC && ! -z $TRK ]] && {
        DISC=$(printf "%02i." $DISC)
    } || {
        DISC=
    }
    [[ ! -z $TRK ]] && TRK=$(printf "%02i -- " $TRK)
    CMD+=" -y '$TARGET/$DISC$TRK$(sanitize "$TITLE").flac'"

    [[ ! -z $NOEXEC ]] && {
        echo $CMD
    } || {
        mkdir -p "$TARGET"
        eval $CMD
    }
done
